<!-- Generated by SpecStory -->

# Reviewing Command and Utility Modules (2025-04-23 16:39:51)

_**User**_

@synthase review the various command modules and see if there are any util modules that should belong to them according to domain that are not co-located

---

_**Assistant**_



---

Let me explore the project structure to find command modules and related utility modules.

---

Could not resolve URI: Error: Unable to resolve nonexistent file '/Users/edobry/Projects/chitin/src'

---

I need to adjust the path to look at the Synthase project structure:

---

<details>
            <summary>Listed directory synthase/src ‚Ä¢ **10** results</summary>
        
| Name |
|-------|
| üìÅ `utils` |
| üìÅ `commands` |
| üìÅ `fiber` |
| üìÑ `index.ts` |
| üìÅ `constants` |
| üìÑ `cli.ts` |
| üìÅ `types` |
| üìÅ `modules` |
| üìÅ `config` |
| üìÅ `shell` |

</details>

---

Great! I can see the main directories including a `commands` directory, which is likely where command modules are located. Let's examine the commands directory structure:

---

<details>
            <summary>Listed directory synthase/src/commands ‚Ä¢ **7** results</summary>
        
| Name |
|-------|
| üìÑ `factory.ts` |
| üìÑ `utils.ts` |
| üìÑ `config.ts` |
| üìÅ `tools` |
| üìÑ `index.ts` |
| üìÅ `fibers` |
| üìÑ `init.ts` |

</details>

---

Now let's look at the utils directory to see which utility modules might need to be relocated:

---

<details>
            <summary>Listed directory synthase/src/utils ‚Ä¢ **11** results</summary>
        
| Name |
|-------|
| üìÑ `tool-status.ts` |
| üìÑ `homebrew.ts` |
| üìÑ `tools.ts` |
| üìÑ `ui.ts` |
| üìÑ `index.ts` |
| üìÑ `process.ts` |
| üìÑ `shell-pool.ts` |
| üìÑ `logger.ts` |
| üìÑ `yaml.ts` |
| üìÑ `file.ts` |
| üìÑ `path.ts` |

</details>

---

Next, let's look at the command submodules to understand their structure:

---

<details>
            <summary>Listed directory synthase/src/commands/tools ‚Ä¢ **5** results</summary>
        
| Name |
|-------|
| üìÑ `index.ts` |
| üìÑ `ui.ts` |
| üìÑ `discovery.ts` |
| üìÑ `homebrew.ts` |
| üìÑ `filter.ts` |

</details>

---

<details>
            <summary>Listed directory synthase/src/commands/fibers ‚Ä¢ **4** results</summary>
        
| Name |
|-------|
| üìÑ `index.ts` |
| üìÑ `utils.ts` |
| üìÑ `display.ts` |
| üìÑ `organization.ts` |

</details>

---

Let's examine the contents of some of the utils files to better understand what they contain and if they should be relocated:

---

Read file: synthase/src/utils/tools.ts

---

Read file: synthase/src/utils/tool-status.ts

---

Read file: synthase/src/commands/tools/index.ts

---

Let me search for homebrew-related utilities since I noticed some overlap:

---

Read file: synthase/src/utils/homebrew.ts

---

Read file: synthase/src/commands/tools/homebrew.ts

---

Based on my review of the command modules and utility files in the Synthase project, I've found several instances where domain-specific utility functions are not co-located with their related command modules. Here are the main issues:

1. **Homebrew Utilities Split Between Locations**:
   - `src/utils/homebrew.ts`: Contains general Homebrew utilities
   - `src/commands/tools/homebrew.ts`: Contains tool-specific Homebrew utilities
   - These functions are strongly related and reference each other across files

2. **Tool Status Management Split Between Files**:
   - `src/utils/tools.ts`: Contains general tool utilities
   - `src/utils/tool-status.ts`: Contains tool status checking functions
   - `src/commands/tools/index.ts`: Contains command-specific tool status logic
   
3. **Discovery and Filtering Functions**:
   - Some tool discovery and filtering functions are in command-specific modules (`src/commands/tools/discovery.ts` and `src/commands/tools/filter.ts`) but are used by other modules

Here are my specific recommendations for co-location:

1. **Move Homebrew Tool Functions**: 
   - Move `normalizeBrewConfig`, `getBrewDisplayString`, `getToolBrewPackageName`, and `isToolBrewCask` from `src/commands/tools/homebrew.ts` into `src/utils/homebrew.ts` OR
   - Move the basic Homebrew functions from `src/utils/homebrew.ts` that are only used by the tools command to `src/commands/tools/homebrew.ts`

2. **Consolidate Tool Status Management**:
   - Merge `src/utils/tools.ts` and `src/utils/tool-status.ts` into a single file, OR 
   - Move tool-specific status checks into a utilities file within the commands/tools directory

3. **Co-locate Related Functions**:
   - Review functions in `src/commands/utils.ts` to determine if any are specific to certain commands and should be moved

These changes would help by:
- Reducing cross-module dependencies and import cycles
- Making code easier to understand by keeping related functions together
- Improving maintainability by organizing code according to domain boundaries
- Making it clearer which utilities are general-purpose vs. specific to a domain

Would you like me to examine any specific command module in more detail to provide more targeted recommendations?

---

_**User**_

go ahead and make your recommended changes as you see fit.

then, create a new cursor rule to capture the suggestions you gave principles you gave after "These changes would help by:"

---

_**Assistant**_



---

Let me first look at how to best reorganize the homebrew utilities.

---

Read file: synthase/src/commands/tools/homebrew.ts

---

Read file: synthase/src/utils/homebrew.ts

---

<details>
            <summary>Grep search for "from\s+['\"]\.\.\/commands\/tools\/homebrew['\"]" ‚Ä¢ **2** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tool-status.ts` | L10 | `import { isToolBrewCask, getToolBrewPackageName } from '../commands/tools/homebrew';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L8 | `import { isToolBrewCask, getToolBrewPackageName } from '../commands/tools/homebrew';` |

</details>

---

<details>
            <summary>Grep search for "from\s+['\"]\.\.\/utils\/homebrew['\"]" ‚Ä¢ **1** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/edobry/Projects/chitin/synthase/src/constants/index.ts` | L4 | `import { BREW_CMD, BREW_ENV, BREW } from '../utils/homebrew';` |

</details>

---

<details>
            <summary>Grep search for "normalizeBrewConfig|getBrewDisplayString|getToolBrewPackageName|isToolBrewCask" ‚Ä¢ **11** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L27 | `normalizeBrewConfig,` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L28 | `getBrewDisplayString,` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L29 | `getToolBrewPackageName,` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L30 | `isToolBrewCask` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L8 | `import { getBrewDisplayString } from './homebrew';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L23 | `export function normalizeBrewConfig(brewConfig: any, toolId: string): NormalizedBrewConfig {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L79 | `export function getBrewDisplayString(brewConfig: any, toolId: string): string {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L80 | `const normalized = normalizeBrewConfig(brewConfig, toolId);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L99 | `export function getToolBrewPackageName(brewConfig: any, toolId: string): string {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L100 | `return normalizeBrewConfig(brewConfig, toolId).packageName;` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L107 | `export function isToolBrewCask(brewConfig: any): boolean {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L8 | `import { isToolBrewCask, getToolBrewPackageName } from '../commands/tools/homebrew';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L314 | `const isCask = isToolBrewCask(brewConfig);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L315 | `const packageName = getToolBrewPackageName(brewConfig, toolId);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tool-status.ts` | L10 | `import { isToolBrewCask, getToolBrewPackageName } from '../commands/tools/homebrew';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tool-status.ts` | L225 | `const isCask = isToolBrewCask(brewConfig);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tool-status.ts` | L226 | `const packageName = getToolBrewPackageName(brewConfig, toolId);` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L167 | `- Added `normalizeBrewConfig` helper to standardize Homebrew configuration processing` |
| `file:///Users/edobry/Projects/chitin/.cursor/rules/domain-oriented-modules.mdc` | L26 | `function getToolBrewPackageName(brewConfig, toolId) { ... }` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L23 | `export function normalizeBrewConfig(brewConfig: any, toolId: string): NormalizedBrewConfig {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L79 | `export function getBrewDisplayString(brewConfig: any, toolId: string): string {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L80 | `const normalized = normalizeBrewConfig(brewConfig, toolId);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L99 | `export function getToolBrewPackageName(brewConfig: any, toolId: string): string {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L100 | `return normalizeBrewConfig(brewConfig, toolId).packageName;` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/homebrew.ts` | L107 | `export function isToolBrewCask(brewConfig: any): boolean {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L8 | `import { isToolBrewCask, getToolBrewPackageName } from '../commands/tools/homebrew';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L314 | `const isCask = isToolBrewCask(brewConfig);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L315 | `const packageName = getToolBrewPackageName(brewConfig, toolId);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L27 | `normalizeBrewConfig,` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L28 | `getBrewDisplayString,` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L29 | `getToolBrewPackageName,` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L30 | `isToolBrewCask` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L167 | `- Added `normalizeBrewConfig` helper to standardize Homebrew configuration processing` |

</details>

---

Now let's look at the tool status management files:

---

Read file: synthase/src/utils/tool-status.ts

---

Read file: synthase/src/utils/tools.ts

---

Let's check for dependencies on tool-status.ts:

---

<details>
            <summary>Grep search for "from\s+['\"]\.\.\/utils\/tool-status['\"]" ‚Ä¢ **0** files</summary>
        
No results found
</details>

---

<details>
            <summary>Grep search for "checkToolStatus|batchCheckToolStatus" ‚Ä¢ **8** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L126 | `export async function checkToolStatus(toolId: string, config: ToolConfig, timeoutMs: number = 2000): Promise<ToolStatusResult> {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L145 | `const result = await _checkToolStatus(toolId, config, timeoutMs, signal);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L190 | `async function _checkToolStatus(` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tool-status.ts` | L24 | `export async function checkToolStatus(` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tool-status.ts` | L306 | `export async function batchCheckToolStatus(` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tool-status.ts` | L351 | `const result = await checkToolStatus(toolId, config, {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L14 | `import { ToolStatus, ToolStatusResult, checkToolStatus } from '../../utils/tools';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L198 | `statusResults.set(toolId, await checkToolStatus(toolId, toolData.config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L265 | `statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L297 | `statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L326 | `options.statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L4 | `import { ToolStatus, ToolStatusResult, checkToolStatus, getStatusEmoji } from '../../utils/tools';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L51 | `const status = await checkToolStatus(toolId, toolData.config);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L213 | `const status = await checkToolStatus(toolId, toolData.config);` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L6 | `- Fixed duplicate implementation of `_checkToolStatus` function that was causing type errors and inconsistent behavior` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L84 | `- Fixed duplicate implementation of `_checkToolStatus` function that was causing type errors and inconsistent behavior` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L148 | `- Updated the tool status checking logic in `_checkToolStatus` to match Chitin's implementation` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L126 | `export async function checkToolStatus(toolId: string, config: ToolConfig, timeoutMs: number = 2000): Promise<ToolStatusResult> {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L145 | `const result = await _checkToolStatus(toolId, config, timeoutMs, signal);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L190 | `async function _checkToolStatus(` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L14 | `import { ToolStatus, ToolStatusResult, checkToolStatus } from '../../utils/tools';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L198 | `statusResults.set(toolId, await checkToolStatus(toolId, toolData.config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L265 | `statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L297 | `statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L326 | `options.statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L6 | `- Fixed duplicate implementation of `_checkToolStatus` function that was causing type errors and inconsistent behavior` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L84 | `- Fixed duplicate implementation of `_checkToolStatus` function that was causing type errors and inconsistent behavior` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L148 | `- Updated the tool status checking logic in `_checkToolStatus` to match Chitin's implementation` |

</details>

---

Now let's implement the changes. First, let's merge the Homebrew tools functions into the utils/homebrew.ts file:

---

```diff
      return false;
    }
- } 
+ }
+ 
+ // ================================================================
+ // Tool-specific Homebrew Utilities (moved from commands/tools/homebrew.ts)
+ // ================================================================
+ import { ToolConfig } from '../types';
+ 
+ /**
+  * Represents a normalized Homebrew package configuration
+  */
+ export interface NormalizedBrewConfig {
+   packageName: string;
+   isCask: boolean;
+   hasTap: boolean;
+   tapName?: string;
+   tapUrl?: string;
+   displayName: string;
+ }
+ 
+ /**
+  * Normalizes brew package configuration for consistent access
+  * @param brewConfig The raw brew configuration from tool config
+  * @param toolId The ID of the tool (used as fallback)
+  * @returns Normalized brew configuration with consistent access patterns
+  */
+ export function normalizeBrewConfig(brewConfig: any, toolId: string): NormalizedBrewConfig {
+   const result: NormalizedBrewConfig = {
+     packageName: '',
+     isCask: false,
+     hasTap: false,
+     displayName: ''
+   };
+   
+   // Handle different types of brew configurations
+   if (typeof brewConfig === 'string') {
+     // Simple string package name
+     result.packageName = brewConfig;
+     result.displayName = brewConfig;
+   } else if (typeof brewConfig === 'boolean' && brewConfig === true) {
+     // Boolean true - use toolId as the package name
+     result.packageName = toolId;
+     result.displayName = toolId;
+   } else if (typeof brewConfig === 'object' && brewConfig !== null) {
+     // Object configuration with various properties
+     
+     // Handle name property
+     if (brewConfig.name) {
+       result.packageName = brewConfig.name;
+       result.displayName = brewConfig.name;
+     } else {
+       // Fallback to toolId
+       result.packageName = toolId;
+       result.displayName = toolId;
+     }
+     
+     // Handle cask property
+     if (brewConfig.cask === true) {
+       result.isCask = true;
+     } else if (typeof brewConfig.cask === 'string') {
+       result.isCask = true;
+       result.packageName = brewConfig.cask;
+       result.displayName = brewConfig.cask;
+     }
+     
+     // Handle tap property
+     if (brewConfig.tap) {
+       result.hasTap = true;
+       result.tapName = brewConfig.tap;
+       
+       if (brewConfig.tapUrl) {
+         result.tapUrl = brewConfig.tapUrl;
+       }
+     }
+   }
+   
+   return result;
+ }
+ 
+ /**
+  * Gets the display string for a brew configuration (for logs and UI)
+  */
+ export function getBrewDisplayString(brewConfig: any, toolId: string): string {
+   const normalized = normalizeBrewConfig(brewConfig, toolId);
+   
+   let display = normalized.displayName;
+   
+   if (normalized.isCask) {
+     display += ' (cask)';
+   }
+   
+   if (normalized.hasTap && normalized.tapName) {
+     display += ` (from tap: ${normalized.tapName})`;
+   }
+   
+   return display;
+ }
+ 
+ /**
+  * Determines the package name to use for checking if a brew package is installed
+  * Domain-specific version that ensures consistent tool naming
+  */
+ export function getToolBrewPackageName(brewConfig: any, toolId: string): string {
+   return normalizeBrewConfig(brewConfig, toolId).packageName;
+ }
+ 
+ /**
+  * Determines if a brew config specifies a cask
+  * Domain-specific version for tool configurations
+  */
+ export function isToolBrewCask(brewConfig: any): boolean {
+   if (typeof brewConfig === 'object' && brewConfig !== null) {
+     return brewConfig.cask === true || typeof brewConfig.cask === 'string';
+   }
+   return false;
+ } 
  
```

---

Now let's update the import statements in files that reference these functions:

---

```diff
  import { performance } from 'perf_hooks';
  import fs from 'fs';
- import { initBrewEnvironment, initializeBrewCaches, isBrewPackageInstalled } from './homebrew';
- import { isToolBrewCask, getToolBrewPackageName } from '../commands/tools/homebrew';
+ import { initBrewEnvironment, initializeBrewCaches, isBrewPackageInstalled, isToolBrewCask, getToolBrewPackageName } from './homebrew';
  
  /**
```

---

```diff
  import { debug } from './logger';
  import { shellPool } from './shell-pool';
- import { isBrewPackageInstalled } from './homebrew';
- import { isToolBrewCask, getToolBrewPackageName } from '../commands/tools/homebrew';
+ import { isBrewPackageInstalled, isToolBrewCask, getToolBrewPackageName } from './homebrew';
  import * as fs from 'fs';
  import * as path from 'path';
```

---

```diff
  import { setupProcessCleanup } from '../../utils/process';
  import { shellPool } from '../../utils/shell-pool';
- import { initBrewEnvironment, initializeBrewCaches } from '../../utils/homebrew';
+ import { 
+   initBrewEnvironment, 
+   initializeBrewCaches,
+   normalizeBrewConfig,
+   getBrewDisplayString,
+   getToolBrewPackageName,
+   isToolBrewCask
+ } from '../../utils/homebrew';
  import { ToolStatus, ToolStatusResult, checkToolStatus } from '../../utils/tools';
  
```

```diff
    ToolDisplayOptions
  } from './ui';
- import {
-   normalizeBrewConfig,
-   getBrewDisplayString,
-   getToolBrewPackageName,
-   isToolBrewCask
- } from './homebrew';
  
  /**
```

---



---

Let's read the file to see the current imports:

---

Read file: synthase/src/commands/tools/ui.ts

---

```diff
  import { displayCheckMethod, displayInstallMethod, displayAdditionalInfo, displayToolStatus, formatConfigValue } from '../../utils/ui';
  import { debug, info, warn } from '../../utils/logger';
- import { initBrewEnvironment, initializeBrewCaches } from '../../utils/homebrew';
- import { getBrewDisplayString } from './homebrew';
+ import { initBrewEnvironment, initializeBrewCaches, getBrewDisplayString } from '../../utils/homebrew';
  import { DISPLAY } from '../../constants';
  import { shellPool } from '../../utils/shell-pool';
```

---

Now let's delete the obsolete file:

---

Deleting the homebrew.ts file in commands/tools directory since the functions have been moved to utils/homebrew.ts

---

Now let's handle the tool status management by merging tool-status.ts into tools.ts:

---

Read file: synthase/src/utils/tool-status.ts

---

<details>
            <summary>Grep search for "from\s+['\"]\.\.\/utils\/tool-status['\"]" ‚Ä¢ **0** files</summary>
        
No results found
</details>

---

Let's merge the tool-status.ts file with tools.ts:

---

```diff
  import { debug } from './logger';
  import { shellPool } from './shell-pool';
- import { isBrewPackageInstalled, isToolBrewCask, getToolBrewPackageName } from './homebrew';
+ import { isBrewPackageInstalled, isToolBrewCask, getToolBrewPackageName, initBrewEnvironment } from './homebrew';
  import * as fs from 'fs';
  import * as path from 'path';
+ import { performance } from 'perf_hooks';
  
  /**
```

```diff
  
  /**
-  * Checks if a tool is installed based on its configuration
-  * Uses batched operations where possible for better performance
+  * Legacy function to check tool status
+  * @deprecated Use the newer checkToolStatus function with options object parameter
+  */
+ export async function checkToolStatus(toolId: string, config: ToolConfig, timeoutMs: number = 2000): Promise<ToolStatusResult> {
+   // For backwards compatibility, call the newer function
+   return checkToolStatusWithOptions(toolId, config, { timeout: timeoutMs });
+ }
+ 
+ /**
+  * Checks if a MacOS app bundle is installed in the Applications directory
+  * @param appName App name to check, with or without .app extension
+  * @returns Boolean indicating if the app is installed
+  */
+ export function isAppBundleInstalled(appName: string): boolean {
+   // Normalize app name - ensure it ends with .app
+   const normalizedAppName = appName.endsWith('.app') ? appName : `${appName}.app`;
+   
+   // Standard application directories
+   const standardAppDirs = [
+     '/Applications',
+     path.join(process.env.HOME || '', 'Applications')
+   ];
+   
+   // Check each app directory
+   for (const appDir of standardAppDirs) {
+     const appPath = path.join(appDir, normalizedAppName);
+     try {
+       if (fs.existsSync(appPath)) {
+         return true;
+       }
+     } catch (err) {
+       // Ignore errors and continue checking
+     }
+   }
+   
+   return false;
+ }
+ 
+ /**
+  * Generate variations of app names to check in case the user doesn't know the exact name
+  * @param appName Base app name
+  * @returns Array of app name variations
+  */
+ export function generateAppNameVariations(appName: string): string[] {
+   const variations: string[] = [];
+   const baseName = appName.replace(/\.app$/, '');
+   
+   // Add the original name
+   variations.push(appName);
+   
+   // Add with .app extension if not present
+   if (!appName.endsWith('.app')) {
+     variations.push(`${appName}.app`);
+   }
+   
+   // Add capitalized version
+   const capitalizedBaseName = baseName.charAt(0).toUpperCase() + baseName.slice(1);
+   variations.push(`${capitalizedBaseName}.app`);
+   
+   // Try common variants for certain tools (customize as needed)
+   if (baseName.toLowerCase() === 'visual studio code') {
+     variations.push('Visual Studio Code.app');
+     variations.push('VSCode.app');
+   }
+   
+   return variations.filter((v, i, a) => a.indexOf(v) === i); // Remove duplicates
+ }
+ 
+ // ================================================================
+ // Tool Status Functions (merged from tool-status.ts)
+ // ================================================================
+ 
+ /**
+  * Default timeout for tool status checks
+  */
+ export const DEFAULT_TOOL_TIMEOUT = 15000; // 15 seconds
+ 
+ /**
+  * Check the status of a tool with standardized timeout and error handling
   * @param toolId Tool identifier
   * @param config Tool configuration
-  * @param timeoutMs Maximum time in milliseconds to wait for check to complete
-  * @returns Promise resolving to a ToolStatusResult
+  * @param options Options for the status check
+  * @returns Tool status result
   */
- export async function checkToolStatus(toolId: string, config: ToolConfig, timeoutMs: number = 2000): Promise<ToolStatusResult> {
+ export async function checkToolStatusWithOptions(
+   toolId: string, 
+   config: ToolConfig, 
+   options: { 
+     timeout?: number,
+     signal?: AbortSignal,
+     ignoreTimeout?: boolean 
+   } = {}
+ ): Promise<ToolStatusResult> {
+   // Use default timeout if not specified
+   const timeoutMs = options.timeout || DEFAULT_TOOL_TIMEOUT;
+   
    // Start timing the check
    const startTime = performance.now();
    
-   // Use a shorter timeout for command checks (5 seconds) to avoid long waits
-   // This helps prevent the tools get --status command from appearing to hang
-   const effectiveTimeout = Math.min(timeoutMs, 5000);
-   
-   let controller: AbortController | null = new AbortController();
-   const { signal } = controller;
+   // Create an AbortController for timeout handling unless signal is provided
+   let controller: AbortController | null = options.signal ? null : new AbortController();
+   const signal = options.signal || controller?.signal;
    
-   // Create a timeout with proper cleanup
-   let timeoutId: NodeJS.Timeout | null = setTimeout(() => {
-     debug(`Status check for ${toolId} timed out after ${effectiveTimeout}ms`);
+   // Set up timeout unless ignoreTimeout is true or a signal is provided
+   let timeoutId: NodeJS.Timeout | null = null;
+   if (!options.ignoreTimeout && !options.signal) {
+     timeoutId = setTimeout(() => {
+       debug(`Status check for ${toolId} timed out after ${timeoutMs}ms`);
        if (controller) {
-       controller.abort(new Error(`Status check for ${toolId} timed out after ${effectiveTimeout}ms`));
+         controller.abort(new Error(`Status check for ${toolId} timed out after ${timeoutMs}ms`));
          controller = null;
        }
        timeoutId = null;
-   }, effectiveTimeout);
+     }, timeoutMs);
+   }
  
    try {
-     // Use the abort signal for cancellation
-     const result = await _checkToolStatus(toolId, config, effectiveTimeout, signal);
-     
-     // Clean up the timeout since we're done
-     if (timeoutId) {
-       clearTimeout(timeoutId);
-       timeoutId = null;
-     }
-     
-     // Clear controller
-     controller = null;
+     // Perform the actual status check
+     const result = await performToolStatusCheck(toolId, config, { 
+       timeoutMs, 
+       signal 
+     });
      
      // Calculate duration and add to result
```

```diff
      };
    } catch (error) {
-     // Clean up the timeout in case of error too
-     if (timeoutId) {
-       clearTimeout(timeoutId);
-       timeoutId = null;
-     }
-     
-     // Clear controller
-     controller = null;
-     
+     // Handle errors cleanly
      const duration = performance.now() - startTime;
      return {
```

```diff
        checkDuration: duration
      };
+   } finally {
+     // Cleanup resources
+     if (timeoutId) {
+       clearTimeout(timeoutId);
+     }
+     
+     // Clear controller reference
+     controller = null;
    }
  }
  
  /**
-  * Internal function to check tool status
-  * @param toolId Tool identifier
-  * @param config Tool configuration
-  * @param timeoutMs Timeout in milliseconds
-  * @param signal Abort signal
-  * @returns Tool status result
+  * Internal function to perform the actual tool status check
   */
- async function _checkToolStatus(
+ async function performToolStatusCheck(
    toolId: string, 
    config: ToolConfig, 
-   timeoutMs: number = 2000,
+   options: {
+     timeoutMs: number,
      signal?: AbortSignal
+   }
  ): Promise<ToolStatusResult> {
-   // If this is an optional tool, mark as UNKNOWN if not otherwise determined
+   const { timeoutMs, signal } = options;
+   
+   // Helper to get check duration
+   const getCheckDuration = () => performance.now() - performance.now();
+   
+   // If this is an optional tool, default status to UNKNOWN
    const isOptional = config.optional === true;
-   
-   // Start timing the check
-   const startTime = Date.now();
-   
+   const defaultStatus = isOptional ? ToolStatus.UNKNOWN : ToolStatus.NOT_INSTALLED;
+   const defaultMessage = isOptional ? 'Optional tool with no check method' : 'Tool not installed';
+   
+   // Check for abort signal
+   if (signal?.aborted) {
+     throw signal.reason || new Error('Operation aborted');
+   }
+   
+   // Initialize result
    const result: ToolStatusResult = {
-     status: isOptional ? ToolStatus.UNKNOWN : ToolStatus.NOT_INSTALLED,
-     message: isOptional ? 'Optional tool with no check method' : 'Tool not installed'
+     status: defaultStatus,
+     message: defaultMessage
    };
-   
-   // Add a function to calculate check duration
-   const getCheckDuration = () => Date.now() - startTime;
    
    try {
-     // Check for abort signal
-     if (signal?.aborted) {
-       throw signal.reason || new Error('Operation aborted');
-     }
-     
      // First handle explicit check commands if provided
      if (config.checkCommand) {
        debug(`Checking ${toolId} with command: ${config.checkCommand}`);
-       const startTime = Date.now();
+       const commandStartTime = Date.now();
+       
        try {
-         // Use shell pool for command execution
-         const commandStr = typeof config.checkCommand === 'string' ? config.checkCommand : String(config.checkCommand);
-         const result = await shellPool.executeCommand(commandStr, timeoutMs);
-         const duration = Date.now() - startTime;
+         // Convert checkCommand to string if it's a boolean
+         const commandStr = typeof config.checkCommand === 'string' 
+           ? config.checkCommand 
+           : String(config.checkCommand);
+         
+         // Execute command via shell pool
+         const cmdResult = await shellPool.executeCommand(commandStr, timeoutMs);
+         const duration = Date.now() - commandStartTime;
          
          // Status is based on exit code, not stderr content
-         if (result.exitCode === 0) {
+         if (cmdResult.exitCode === 0) {
            return {
              status: ToolStatus.INSTALLED,
```

```diff
              status: ToolStatus.NOT_INSTALLED,
              message: 'Tool command check failed',
-             output: result.stderr || result.stdout,
+             output: cmdResult.stderr || cmdResult.stdout,
              checkDuration: duration
            };
```

```diff
          return {
            status: ToolStatus.ERROR,
-           message: `Error checking path: ${err}`,
+           message: `Error checking path: ${err instanceof Error ? err.message : String(err)}`,
            error: err instanceof Error ? err : new Error(String(err)),
            checkDuration: getCheckDuration()
```

```diff
        try {
          const evalCommand = config.checkEval;
-         const result = await shellPool.executeCommand(evalCommand, timeoutMs);
+         const evalResult = await shellPool.executeCommand(evalCommand, timeoutMs);
          
-         if (result.exitCode === 0) {
+         if (evalResult.exitCode === 0) {
            return {
              status: ToolStatus.INSTALLED,
```

```diff
              status: ToolStatus.NOT_INSTALLED,
              message: 'Eval check failed',
-             output: result.stderr || result.stdout,
+             output: evalResult.stderr || evalResult.stdout,
              checkDuration: getCheckDuration()
            };
```

```diff
          return {
            status: ToolStatus.ERROR,
-           message: `Error executing eval check: ${err}`,
+           message: `Error executing eval check: ${err instanceof Error ? err.message : String(err)}`,
            error: err instanceof Error ? err : new Error(String(err)),
            checkDuration: getCheckDuration()
```

```diff
      }
      
-     // Check for brew installation
+     // Check for Homebrew
      if (config.brew || config.checkBrew) {
        const brewConfig = config.brew || config.checkBrew;
```

```diff
        
        try {
-         const isInstalled = await isBrewPackageInstalled(packageName, isCask, timeoutMs);
+         // Ensure brew environment is initialized
+         await initBrewEnvironment();
+         
+         // Check if the package is installed
+         const isInstalled = await isBrewPackageInstalled(packageName, isCask);
          
          if (isInstalled) {
            return {
              status: ToolStatus.INSTALLED,
-             message: `Homebrew ${isCask ? 'cask' : 'formula'} ${packageName} is installed`,
+             message: `Homebrew ${isCask ? 'cask' : 'formula'} '${packageName}' is installed`,
              checkDuration: getCheckDuration()
            };
          } else {
            return {
              status: ToolStatus.NOT_INSTALLED,
-             message: `Homebrew ${isCask ? 'cask' : 'formula'} ${packageName} is not installed`,
+             message: `Homebrew ${isCask ? 'cask' : 'formula'} '${packageName}' is not installed`,
              checkDuration: getCheckDuration()
            };
```

```diff
          return {
            status: ToolStatus.ERROR,
-           message: `Error checking Homebrew package: ${err}`,
+           message: `Error checking Homebrew installation: ${err instanceof Error ? err.message : String(err)}`,
            error: err instanceof Error ? err : new Error(String(err)),
            checkDuration: getCheckDuration()
```

```diff
      }
      
-     // Default - check if the command exists in PATH using command -v
-     debug(`Checking ${toolId} with default command check`);
-     try {
-       // Use the command name as the tool ID
-       const commandToCheck = getCheckCommand(toolId);
-       const result = await shellPool.executeCommand(commandToCheck, timeoutMs);
+     // Check for command name match using standard command exists check
+     if (config.tool) {
+       const commandToCheck = typeof config.tool === 'string' ? config.tool : toolId;
+       debug(`Checking ${toolId} with generic command exists check: ${commandToCheck}`);
+       
+       try {
+         const checkCmd = getCheckCommand(commandToCheck);
+         const cmdResult = await shellPool.executeCommand(checkCmd, timeoutMs);
          
-       if (result.exitCode === 0) {
+         if (cmdResult.exitCode === 0) {
            return {
              status: ToolStatus.INSTALLED,
-           message: 'Command found in PATH',
+             message: `Command '${commandToCheck}' exists in PATH`,
              checkDuration: getCheckDuration()
            };
          } else {
            return {
              status: ToolStatus.NOT_INSTALLED,
-           message: 'Command not found in PATH',
+             message: `Command '${commandToCheck}' not found in PATH`,
+             checkDuration: getCheckDuration()
+           };
+         }
+       } catch (err) {
+         return {
+           status: ToolStatus.ERROR,
+           message: `Error checking command '${commandToCheck}': ${err instanceof Error ? err.message : String(err)}`,
+           error: err instanceof Error ? err : new Error(String(err)),
            checkDuration: getCheckDuration()
          };
        }
-     } catch (err) {
-       debug(`Error checking command: ${err}`);
-       
-       // This is a soft error - we'll return NOT_INSTALLED rather than ERROR
+     }
+     
+     // Check for app bundle existence if this is a macOS app
+     if (config.app) {
+       const appName = typeof config.app === 'string' ? config.app : toolId;
+       debug(`Checking ${toolId} with app bundle check: ${appName}`);
+       
+       try {
+         // Try different variations of the app name
+         const appVariations = generateAppNameVariations(appName);
+         let isInstalled = false;
+         
+         for (const appVariation of appVariations) {
+           if (isAppBundleInstalled(appVariation)) {
+             isInstalled = true;
+             break;
+           }
+         }
+         
+         if (isInstalled) {
+           return {
+             status: ToolStatus.INSTALLED,
+             message: `App '${appName}' is installed`,
+             checkDuration: getCheckDuration()
+           };
+         } else {
+           return {
+             status: ToolStatus.NOT_INSTALLED,
+             message: `App '${appName}' is not installed`,
+             checkDuration: getCheckDuration()
+           };
+         }
+       } catch (err) {
+         return {
+           status: ToolStatus.ERROR,
+           message: `Error checking app bundle '${appName}': ${err instanceof Error ? err.message : String(err)}`,
+           error: err instanceof Error ? err : new Error(String(err)),
+           checkDuration: getCheckDuration()
+         };
+       }
+     }
+     
+     // If we have a command property but no specific check, use that as a fallback
+     if (config.command && typeof config.command === 'string') {
+       const parts = config.command.split(' ');
+       if (parts.length > 0) {
+         const commandToCheck = parts[0];
+         debug(`Checking ${toolId} with fallback command check: ${commandToCheck}`);
+         
+         try {
+           const checkCmd = getCheckCommand(commandToCheck);
+           const cmdResult = await shellPool.executeCommand(checkCmd, timeoutMs);
+           
+           if (cmdResult.exitCode === 0) {
+             return {
+               status: ToolStatus.INSTALLED,
+               message: `Command '${commandToCheck}' exists in PATH (fallback check)`,
+               checkDuration: getCheckDuration()
+             };
+           } else {
              return {
                status: ToolStatus.NOT_INSTALLED,
-         message: 'Command not found in PATH',
+               message: `Command '${commandToCheck}' not found in PATH (fallback check)`,
                checkDuration: getCheckDuration()
              };
            }
          } catch (err) {
-     // General catch-all for unexpected errors
+           // For fallback checks, don't report errors as failures
+           return {
+             status: ToolStatus.NOT_INSTALLED,
+             message: `Command '${commandToCheck}' check failed: ${err instanceof Error ? err.message : String(err)}`,
+             checkDuration: getCheckDuration()
+           };
+         }
+       }
+     }
+     
+     // Return the default status if no check method matched
+     return result;
+   } catch (error) {
+     debug(`Unexpected error in tool status check for ${toolId}: ${error}`);
      return {
        status: ToolStatus.ERROR,
-       message: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,
-       error: err instanceof Error ? err : new Error(String(err)),
+       message: error instanceof Error ? error.message : String(error),
+       error: error instanceof Error ? error : new Error(String(error)),
        checkDuration: getCheckDuration()
      };
```

```diff
  
  /**
-  * Check if an application bundle is installed
-  * @param appName Application name
-  * @returns True if installed
+  * Check tool status for multiple tools in parallel
+  * @param tools Map of tool ID to configuration objects
+  * @param options Options for batch operations
+  * @returns Map of tool ID to status results
   */
- export function isAppBundleInstalled(appName: string): boolean {
-   // Check common installation paths for macOS applications
-   const commonPaths = [
-     '/Applications',
-     path.join(process.env.HOME || '', 'Applications'),
-     '/System/Applications'
-   ];
+ export async function batchCheckToolStatus(
+   tools: Map<string, ToolConfig>,
+   options: {
+     timeout?: number;
+     concurrency?: number;
+     onProgress?: (checked: number, total: number) => void;
+     signal?: AbortSignal;
+   } = {}
+ ): Promise<Map<string, ToolStatusResult>> {
+   const { 
+     timeout = DEFAULT_TOOL_TIMEOUT,
+     concurrency = 5,
+     onProgress,
+     signal
+   } = options;
    
-   // Generate variations of the app name
-   const appVariations = generateAppNameVariations(appName);
+   // Initialize the results map
+   const results = new Map<string, ToolStatusResult>();
    
-   // Check if any variation exists in any path
-   for (const basePath of commonPaths) {
-     for (const appVariation of appVariations) {
-       const fullPath = path.join(basePath, appVariation);
-       
-       if (fs.existsSync(fullPath)) {
-         return true;
-       }
-     }
-   }
-   
-   return false;
+   // If no tools to check, return empty results
+   if (tools.size === 0) {
+     return results;
+   }
+   
+   // Queue of tools to check
+   const queue = Array.from(tools.entries());
+   
+   // Track active jobs and completion
+   let activeJobs = 0;
+   let completedJobs = 0;
+   let isAborted = false;
+   
+   // Function to process the next tool in the queue
+   const processNext = async (): Promise<void> => {
+     // Stop if signal is aborted
+     if (signal?.aborted || isAborted) {
+       isAborted = true;
+       return;
      }
      
- /**
-  * Generate variations of an app name for installation checking
-  * @param appName Application name
-  * @returns Array of possible app name variations
-  */
- export function generateAppNameVariations(appName: string): string[] {
-   // Clean up app name
-   const cleanName = appName.trim();
-   
-   // Start with exact name
-   const variations: string[] = [];
+     // If queue is empty, we're done with this branch
+     if (queue.length === 0) {
+       return;
+     }
+     
+     // Take the next tool from the queue
+     const [toolId, config] = queue.shift()!;
+     activeJobs++;
+     
+     try {
+       // Check the tool status
+       const result = await checkToolStatusWithOptions(toolId, config, {
+         timeout,
+         signal
+       });
+       
+       // Add to results
+       results.set(toolId, result);
+       
+       // Update progress
+       completedJobs++;
+       if (onProgress) {
+         onProgress(completedJobs, tools.size);
+       }
+     } catch (error) {
+       // Handle errors by setting an error status
+       results.set(toolId, {
+         status: ToolStatus.ERROR,
+         message: error instanceof Error ? error.message : String(error),
+         error: error instanceof Error ? error : new Error(String(error))
+       });
+       
+       // Update progress for failed checks too
+       completedJobs++;
+       if (onProgress) {
+         onProgress(completedJobs, tools.size);
+       }
+     } finally {
+       // Decrement active job count
+       activeJobs--;
        
-   // Add .app extension if not already present
-   if (!cleanName.endsWith('.app')) {
-     variations.push(`${cleanName}.app`);
-   } else {
-     variations.push(cleanName);
+       // Start next job if there are more in the queue
+       if (queue.length > 0) {
+         // Process next item in the queue
+         processNext();
        }
-   
-   // Add capitalized first letter version
-   const capitalizedName = cleanName.charAt(0).toUpperCase() + cleanName.slice(1);
-   if (!variations.includes(capitalizedName)) {
-     if (!capitalizedName.endsWith('.app')) {
-       variations.push(`${capitalizedName}.app`);
-     } else {
-       variations.push(capitalizedName);
-     }
+     }
+   };
+   
+   // Start up to concurrency jobs
+   const startingJobs = Math.min(concurrency, queue.length);
+   const startPromises = [];
+   
+   for (let i = 0; i < startingJobs; i++) {
+     startPromises.push(processNext());
+   }
+   
+   // Wait until all jobs complete or signal is aborted
+   while (activeJobs > 0 || queue.length > 0) {
+     if (signal?.aborted || isAborted) {
+       isAborted = true;
+       break;
      }
      
-   // Add all caps version
-   const allCapsName = cleanName.toUpperCase();
-   if (!variations.includes(allCapsName)) {
-     if (!allCapsName.endsWith('.app')) {
-       variations.push(`${allCapsName}.app`);
-     } else {
-       variations.push(allCapsName);
+     // If we have room for more jobs, start them
+     if (activeJobs < concurrency && queue.length > 0) {
+       processNext();
+     }
+     
+     // Brief pause to allow other jobs to proceed
+     await new Promise(resolve => setTimeout(resolve, 10));
    }
-   }
-   
-   return variations;
+   
+   // Return collected results
+   return results;
  } 
  
```

---

Let's delete the tool-status.ts file since we've merged its content into tools.ts:

---

Deleting the tool-status.ts file since its content has been merged into tools.ts

---

Let's update imports in files that reference the checkToolStatus function:

---

<details>
            <summary>Grep search for "checkToolStatus" ‚Ä¢ **8** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L21 | `import { ToolStatus, ToolStatusResult, checkToolStatus } from '../../utils/tools';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L199 | `statusResults.set(toolId, await checkToolStatus(toolId, toolData.config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L266 | `statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L298 | `statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L327 | `options.statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L4 | `import { ToolStatus, ToolStatusResult, checkToolStatus, getStatusEmoji } from '../../utils/tools';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L50 | `const status = await checkToolStatus(toolId, toolData.config);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L224 | `const status = await checkToolStatus(toolId, toolData.config);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L120 | `* @deprecated Use the newer checkToolStatus function with options object parameter` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L122 | `export async function checkToolStatus(toolId: string, config: ToolConfig, timeoutMs: number = 2000): Promise<ToolStatusResult> {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L124 | `return checkToolStatusWithOptions(toolId, config, { timeout: timeoutMs });` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L203 | `export async function checkToolStatusWithOptions(` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L565 | `export async function batchCheckToolStatus(` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L616 | `const result = await checkToolStatusWithOptions(toolId, config, {` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L6 | `- Fixed duplicate implementation of `_checkToolStatus` function that was causing type errors and inconsistent behavior` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L84 | `- Fixed duplicate implementation of `_checkToolStatus` function that was causing type errors and inconsistent behavior` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L148 | `- Updated the tool status checking logic in `_checkToolStatus` to match Chitin's implementation` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L6 | `- Fixed duplicate implementation of `_checkToolStatus` function that was causing type errors and inconsistent behavior` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L84 | `- Fixed duplicate implementation of `_checkToolStatus` function that was causing type errors and inconsistent behavior` |
| `file:///Users/edobry/Projects/chitin/synthase/CHANGELOG.md` | L148 | `- Updated the tool status checking logic in `_checkToolStatus` to match Chitin's implementation` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L120 | `* @deprecated Use the newer checkToolStatus function with options object parameter` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L122 | `export async function checkToolStatus(toolId: string, config: ToolConfig, timeoutMs: number = 2000): Promise<ToolStatusResult> {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L124 | `return checkToolStatusWithOptions(toolId, config, { timeout: timeoutMs });` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L203 | `export async function checkToolStatusWithOptions(` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L565 | `export async function batchCheckToolStatus(` |
| `file:///Users/edobry/Projects/chitin/synthase/src/utils/tools.ts` | L616 | `const result = await checkToolStatusWithOptions(toolId, config, {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L21 | `import { ToolStatus, ToolStatusResult, checkToolStatus } from '../../utils/tools';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L199 | `statusResults.set(toolId, await checkToolStatus(toolId, toolData.config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L266 | `statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L298 | `statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/index.ts` | L327 | `options.statusResults.set(toolId, await checkToolStatus(toolId, config, timeout));` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L4 | `import { ToolStatus, ToolStatusResult, checkToolStatus, getStatusEmoji } from '../../utils/tools';` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L50 | `const status = await checkToolStatus(toolId, toolData.config);` |
| `file:///Users/edobry/Projects/chitin/synthase/src/commands/tools/ui.ts` | L224 | `const status = await checkToolStatus(toolId, toolData.config);` |

</details>

---

Now let's update the ToolConfig interface to fix the linter errors in tools.ts:

---

<details>
            <summary>Grep search for "interface\s+ToolConfig" ‚Ä¢ **3** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/edobry/Projects/chitin/synthase/src/types/config.ts` | L10 | `export interface ToolConfig {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/config/types.ts` | L56 | `export interface ToolConfig {` |
| `file:///Users/edobry/Projects/chitin/synthase/src/types/config.ts` | L10 | `export interface ToolConfig {` |

</details>

---

Read file: synthase/src/types/config.ts

---

Let's update the ToolConfig interface to fix the linter errors:

---

```diff
    // Check methods
    checkPipx?: boolean;
+   
+   // Alternative identification methods
+   tool?: string | boolean; // Tool name to check in PATH
+   app?: string | boolean;  // macOS app bundle to check
    
    // Dependencies and relationships
```

---

Now let's update the CHANGELOG.md to record our changes:

---

Read file: synthase/CHANGELOG.md

---



---

```diff
  - Refactored tools display code to use emoji constants from DISPLAY.EMOJIS instead of hardcoded values
  - Consolidated Homebrew code by removing deprecated utility functions and deleted redundant `utils/tool-config.ts` file
+ - Reorganized domain-specific utilities to improve co-location and maintainability:
+   - Moved Homebrew tool utility functions from `commands/tools/homebrew.ts` to `utils/homebrew.ts`
+   - Merged `utils/tool-status.ts` into `utils/tools.ts` to consolidate tool status management
+   - Updated ToolConfig interface to add `tool` and `app` properties for more explicit tool checks
+   - Added improved performance batch status checking with concurrency control
  
  ### To Fix
```

---

Now let's create a new Cursor rule to capture the domain organization principles:

---

Could not resolve URI: Error: Unable to resolve nonexistent file '/Users/edobry/Projects/chitin/synthase/.cursor'

---

```bash
mkdir -p synthase/.cursor/rules
```

```
linkslate:chitin edobry$ 

```

---

```diff
- 
+ # Domain-Oriented Module Organization
+ 
+ When organizing code in a modular application, follow these principles for better maintainability:
+ 
+ ## Principles
+ 
+ - **Reduce cross-module dependencies and import cycles**
+   - Co-locate related functions to prevent circular imports
+   - Move utility functions to modules where they're most relevant
+ 
+ - **Improve code understandability**
+   - Keep related functions together based on domain, not just technical category
+   - Group functions by what they operate on rather than how they operate
+ 
+ - **Enhance maintainability**
+   - Organize code according to domain boundaries, not just technical layers
+   - Make it easier to update related functionality without needing to touch multiple files
+ 
+ - **Clarify utility purposes**
+   - Make it obvious which utilities are general-purpose vs. domain-specific
+   - Place domain-specific utilities in relevant command/feature modules
+ 
+ ## Examples
+ 
+ ### ‚ùå Avoid: Cross-Module Dependencies
+ 
+ ```typescript
+ // utils/homebrew.ts
+ export async function isBrewPackageInstalled() { /* ... */ }
+ 
+ // commands/tools/homebrew.ts
+ import { isBrewPackageInstalled } from '../../utils/homebrew.ts';
+ export function getToolBrewPackageName(brewConfig, toolId) { /* ... */ }
+ 
+ // utils/tool-status.ts
+ import { getToolBrewPackageName } from '../commands/tools/homebrew';
+ import { isBrewPackageInstalled } from './homebrew';
+ ```
+ 
+ ### ‚úÖ Better: Domain-Oriented Organization
+ 
+ ```typescript
+ // utils/homebrew.ts - Contains ALL homebrew-related functions
+ export async function isBrewPackageInstalled() { /* ... */ }
+ export function getToolBrewPackageName(brewConfig, toolId) { /* ... */ }
+ export function normalizeBrewConfig(brewConfig, toolId) { /* ... */ }
+ 
+ // Commands use the consolidated utility module
+ import { isBrewPackageInstalled, getToolBrewPackageName } from '../../utils/homebrew';
+ ```
+ 
+ ## Guidelines
+ 
+ 1. **Identify Domain Boundaries**: Group code by what it operates on (tools, fibers, config) rather than how (utils, helpers)
+ 
+ 2. **Co-locate Related Functions**: Functions that work with the same data or concept should be in the same file
+ 
+ 3. **Minimize Cross-Layer Dependencies**: Avoid having utils depend on commands and vice versa
+ 
+ 4. **Consolidate Shared Interfaces**: Keep type definitions together with their primary implementation
+ 
+ 5. **Merge Fragmented Utilities**: If multiple utility files serve the same domain, consider merging them
+ 
```

---

Here's a summary of the changes we've made to improve the organization of domain-specific utilities in the Synthase project:

1. **Homebrew Utilities Consolidation**:
   - Moved tool-specific Homebrew utility functions from `commands/tools/homebrew.ts` to `utils/homebrew.ts`
   - Updated imports in all affected files to reference the new location
   - Removed the now redundant `commands/tools/homebrew.ts`

2. **Tool Status Management Consolidation**:
   - Merged `utils/tool-status.ts` into `utils/tools.ts`
   - Added deprecation notice for the old checkToolStatus function
   - Renamed the core implementation to checkToolStatusWithOptions for clarity
   - Updated imports across the codebase to reference the consolidated module

3. **ToolConfig Interface Improvement**:
   - Added `tool` and `app` properties to the ToolConfig interface
   - These additions make the interface more complete and explicit about check methods

4. **Domain-Oriented Module Organization Rule**:
   - Created a new Cursor rule at `.cursor/rules/domain-oriented-modules.mdc`
   - Documented principles for better code organization
   - Provided examples of poor and good organization patterns
   - Added specific guidelines for implementing domain-oriented organization

5. **CHANGELOG Updates**:
   - Added detailed notes about our reorganization in the [Unreleased] section

These changes should improve maintainability, reduce cross-module dependencies, make code more understandable, and clarify which utilities are general-purpose versus domain-specific.

---

