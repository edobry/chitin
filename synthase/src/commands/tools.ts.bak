import { Command } from 'commander';
import { serializeToYaml } from '../utils';
import { loadAndValidateConfig } from './utils';
import { UserConfig, ToolConfig, FiberConfig, ChainConfig, Module } from '../types';
import { discoverModulesFromConfig } from '../modules/discovery';
import { loadYamlFile } from '../utils/yaml';
import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { exec } from 'child_process';
import { promisify } from 'util';

// Import shared utilities
import { debug, error, info, warn, LogLevel, setLogLevel } from '../utils/logger';
import { setupProcessCleanup } from '../utils/process';
import { shellPool } from '../utils/shell-pool';
import { initBrewEnvironment, initializeBrewCaches, isBrewPackageInstalled, 
         isBrewCask, getBrewPackageName } from '../utils/homebrew';
import { ToolStatus, ToolStatusResult, checkToolStatus, getToolCheckMethod, 
         getToolInstallMethod, isAppBundleInstalled } from '../utils/tools';
import { displayCheckMethod, displayInstallMethod, displayAdditionalInfo, 
         displayToolStatus, showInstallationHint, formatConfigValue } from '../utils/ui';

/**
 * Creates a tools command
 * @returns Configured Command object
 */
export function createToolsCommand(): Command {
  const cmd = new Command('tools')
    .description('Manage and display tool configurations')
    .addCommand(
      new Command('get')
        .description('Get detailed information about configured tools')
        .argument('[toolName]', 'Optional tool name to display')
        .option('-d, --detailed', 'Show detailed tool configuration')
        .option('--status', 'Check if tools are installed')
        .option('--missing', 'Only show tools that are not installed')
        .option('--filter-source <source>', 'Filter tools by source')
        .option('--filter-check <method>', 'Filter tools by check method')
        .option('--filter-install <method>', 'Filter tools by install method')
        .option('-y, --yes', 'Skip confirmation when checking many tools')
        .option('--json', 'Output in JSON format')
        .option('--yaml', 'Output in YAML format')
        .action(handleToolsCommand)
    )
    .addCommand(
      new Command('list')
        .description('List tool names for scripts')
        .option('--filter-source <source>', 'Filter tools by source')
        .option('--filter-check <method>', 'Filter tools by check method')
        .option('--filter-install <method>', 'Filter tools by install method')
        .action(handleListCommand)
    );
  
  // Make 'get' the default subcommand when none is specified
  cmd.action((options) => {
    handleToolsCommand(undefined, options);
  });
  
  // Set up process cleanup
  setupProcessCleanup();
  
  return cmd;
}

/**
 * Filter tools based on specified criteria
 * @param tools Tools map
 * @param options Filter options
 * @returns Filtered tools map
 */
function filterTools(
  tools: Map<string, { config: ToolConfig, source: string }>,
  options: { filterSource?: string, filterCheck?: string, filterInstall?: string }
): Map<string, { config: ToolConfig, source: string }> {
  const { filterSource, filterCheck, filterInstall } = options;
  
  if (!filterSource && !filterCheck && !filterInstall) {
    return tools;
  }
  
  const filtered = new Map();
  
  for (const [toolId, { config, source }] of tools.entries()) {
    let include = true;
    
    // Filter by source
    if (filterSource && !source.toLowerCase().includes(filterSource.toLowerCase())) {
      include = false;
    }
    
    // Filter by check method
    if (filterCheck && getToolCheckMethod(config).toLowerCase() !== filterCheck.toLowerCase()) {
      include = false;
    }
    
    // Filter by install method
    if (filterInstall && getToolInstallMethod(config).toLowerCase() !== filterInstall.toLowerCase()) {
      include = false;
    }
    
    if (include) {
      filtered.set(toolId, { config, source });
    }
  }
  
  return filtered;
}

/**
 * Handle the list command
 * @param options Command options
 */
async function handleListCommand(options: any): Promise<void> {
  try {
    if (process.env.DEBUG === 'true') {
      setLogLevel(LogLevel.DEBUG);
    }
    
    // Initialize the shell pool early
    await shellPool.initialize();
    
    // Load configuration and validate
    const { config } = await loadAndValidateConfig();
    
    debug('Discovering modules');
    
    // Discover modules
    const discoveryResult = await discoverModulesFromConfig(config);
    const modules: Module[] = discoveryResult.modules || [];
    
    debug(`Found ${modules.length} modules`);
    
    // Initialize the parent project configuration
    // Always try to find the parent first
    let parentConfig = loadParentConfig(process.cwd());
    
    // Extract tools from all sources
    const tools = extractAllTools(config, modules);
    
    // Apply filters
    const filteredTools = filterTools(tools, {
      filterSource: options.filterSource,
      filterCheck: options.filterCheck,
      filterInstall: options.filterInstall
    });
    
    // Output tool names one per line for scripting use
    for (const toolId of filteredTools.keys()) {
      console.log(toolId);
    }
  } catch (err) {
    console.error(`Error: ${err instanceof Error ? err.message : String(err)}`);
    process.exit(1);
  }
}

/**
 * Load the parent configuration if available
 * @param filePath Current directory or file path
 * @returns Parent configuration or null
 */
function loadParentConfig(filePath: string): any {
  try {
    const dir = fs.statSync(filePath).isDirectory() ? filePath : path.dirname(filePath);
    const parentConfigPath = path.join(dir, 'config.yaml');

    if (fs.existsSync(parentConfigPath)) {
      debug(`Found parent config at ${parentConfigPath}`);
      return loadYamlFile(parentConfigPath);
    }
  } catch (err) {
    debug(`Error loading parent config: ${err}`);
  }
  
  return null;
}

/**
 * Extract all tools from the configuration and modules
 * @param config User configuration
 * @param modules Discovered modules
 * @param rootModuleName Optional root module name
 * @returns Map of tools with their configurations and sources
 */
function extractAllTools(
  config: UserConfig, 
  modules: Module[] = [],
  rootModuleName: string = ''
): Map<string, { config: ToolConfig, source: string }> {
  const tools = new Map<string, { config: ToolConfig, source: string }>();
  
  // Function to add a tool to the map
  const addTool = (toolId: string, toolConfig: ToolConfig, source: string) => {
    if (!tools.has(toolId)) {
      tools.set(toolId, { config: toolConfig, source });
    }
  };
  
  // Process a module's tools
  const processModuleTools = (moduleId: string, moduleConfig: ChainConfig | FiberConfig) => {
    if (!moduleConfig || !moduleConfig.tools) return;
    
    for (const [toolId, toolConfig] of Object.entries(moduleConfig.tools)) {
      addTool(toolId, toolConfig, moduleId);
    }
  };
  
  // Process modules discovered from the file system
  modules.forEach(module => {
    const moduleId = module.id;
    const moduleConfig = module.config;
    
    if (moduleConfig) {
      processModuleTools(moduleId, moduleConfig);
    }
  });
  
  // Process user config for explicit tool definitions
  Object.entries(config).forEach(([fiberName, fiberConfig]) => {
    if (fiberName === 'core') return; // Skip core config as it's not a fiber
    
    // Process fiber-level tools
    processModuleTools(fiberName, fiberConfig as FiberConfig);
    
    // Process chain-level tools
    const moduleConfig = (fiberConfig as FiberConfig).moduleConfig;
    if (moduleConfig) {
      Object.entries(moduleConfig).forEach(([chainName, chainConfig]) => {
        const chainId = `${fiberName}:${chainName}`;
        processModuleTools(chainId, chainConfig);
      });
    }
  });
  
  // Process core config for global tools
  if (config.core && config.core.moduleConfig) {
    Object.entries(config.core.moduleConfig).forEach(([chainName, chainConfig]) => {
      const chainId = `chitin:${chainName}`;
      processModuleTools(chainId, chainConfig);
    });
  }
  
  return tools;
}

/**
 * Display information about a single tool
 * @param toolId Tool identifier
 * @param toolData Tool data
 * @param options Display options
 */
async function displaySingleTool(
  toolId: string,
  toolData: { config: ToolConfig, source: string },
  options: { detailed?: boolean, status?: boolean, statusResult?: ToolStatusResult }
): Promise<void> {
  const { config, source } = toolData;
  
  // Tool header with tool identifier  
  console.log(`${toolId} (Source: ${source})`);
  
  // Display check method
  displayCheckMethod(toolId, config);
  
  // Display installation method if available
  displayInstallMethod(config);
  
  // Display additional info
  displayAdditionalInfo(config);
  
  // Show detailed configuration if requested
  if (options.detailed) {
    console.log(`  Full Configuration: ${formatConfigValue(config)}`);
  }
  
  // Show status information if requested or provided
  if (options.status || options.statusResult) {
    const statusResult = options.statusResult || 
                        await checkToolStatus(toolId, config);
    displayToolStatus(statusResult);
  }
  
  console.log(); // Empty line for spacing
}

/**
 * Display information about multiple tools
 * @param tools Tools map
 * @param options Display options
 */
async function displayTools(
  tools: Map<string, { config: ToolConfig, source: string }>,
  options: { 
    detailed?: boolean, 
    status?: boolean, 
    missing?: boolean, 
    statusResults?: Map<string, ToolStatusResult>,
    filterSource?: string, 
    filterCheck?: string, 
    filterInstall?: string,
    skipStatusWarning?: boolean  
  }
): Promise<void> {
  if (tools.size === 0) {
    console.log('No tools found matching the criteria.');
    return;
  }
  
  // Check if we need to show a warning about checking many tools
  if (options.status && !options.skipStatusWarning && tools.size > 10) {
    const filtered = options.filterSource || options.filterCheck || options.filterInstall;
    
    if (!filtered) {
      warn(`You're about to check the status of ${tools.size} tools, which may take some time.`);
      warn('Consider using filters (--filter-source, --filter-check, --filter-install) to narrow down the list.');
      warn('Press Ctrl+C to cancel, or wait 5 seconds to continue...');
      
      await new Promise(resolve => setTimeout(resolve, 5000));
    } else {
      // Show a different message if filters are already applied
      info(`Checking status of ${tools.size} tools (filtered)...`);
    }
  }
  
  // If we need to check the status of all tools
  if (options.status && !options.statusResults) {
    const statusResults = new Map<string, ToolStatusResult>();
    let processedCount = 0;
    
    // Initialize Homebrew environment if needed
    if (tools.size > 0) {
      const hasBrewTools = Array.from(tools.values()).some(
        tool => tool.config.brew || tool.config.checkBrew
      );
      
      if (hasBrewTools) {
        debug('Initializing Homebrew environment for status checks');
        await initBrewEnvironment();
        await initializeBrewCaches();
      }
    }
    
    // Check the status of all tools in batches
    const batchSize = 5; // Process 5 tools at once
    const toolEntries = Array.from(tools.entries());
    
    // Process tools in batches for better performance
    for (let i = 0; i < toolEntries.length; i += batchSize) {
      const batch = toolEntries.slice(i, i + batchSize);
      
      // Process each batch in parallel
      await Promise.all(batch.map(async ([toolId, { config }]) => {
        try {
          const result = await checkToolStatus(toolId, config);
          statusResults.set(toolId, result);
          processedCount++;
          
          // Show progress periodically
          if (processedCount % 10 === 0 || processedCount === toolEntries.length) {
            debug(`Checked ${processedCount}/${toolEntries.length} tools`);
          }
        } catch (err) {
          debug(`Error checking status for ${toolId}: ${err}`);
          statusResults.set(toolId, {
            status: ToolStatus.ERROR,
            error: err instanceof Error ? err : new Error(String(err))
          });
        }
      }));
    }
    
    options.statusResults = statusResults;
  }
  
  // If we only want to show missing tools
  if (options.missing && options.statusResults) {
    const missingTools = new Map();
    
    for (const [toolId, { config, source }] of tools.entries()) {
      const statusResult = options.statusResults.get(toolId);
      
      if (statusResult && statusResult.status === ToolStatus.NOT_INSTALLED) {
        missingTools.set(toolId, { config, source });
      }
    }
    
    if (missingTools.size === 0) {
      console.log('All tools are installed! 🎉');
      return;
    }
    
    console.log(`Found ${missingTools.size} missing tools:`);
    console.log();
    tools = missingTools;
  }
  
  // Display each tool
  for (const [toolId, { config, source }] of tools.entries()) {
    try {
      const statusResult = options.statusResults?.get(toolId);
      
      await displaySingleTool(toolId, { config, source }, {
        detailed: options.detailed,
        status: options.status,
        statusResult
      });
    } catch (err) {
      error(`Error displaying tool ${toolId}: ${err}`);
    }
  }
  
  // Show statistics
  console.log(`Total tools: ${tools.size}`);
  
  if (options.statusResults) {
    const installedCount = Array.from(options.statusResults.values())
      .filter(result => result.status === ToolStatus.INSTALLED)
      .length;
    
    const missingCount = Array.from(options.statusResults.values())
      .filter(result => result.status === ToolStatus.NOT_INSTALLED)
      .length;
    
    const errorCount = Array.from(options.statusResults.values())
      .filter(result => result.status === ToolStatus.ERROR)
      .length;
    
    console.log(`Installed: ${installedCount}, Missing: ${missingCount}, Errors: ${errorCount}`);
  }
}

/**
 * Handle the tools command
 * @param toolName Optional tool name to display
 * @param options Command options
 */
async function handleToolsCommand(toolName: string | undefined, options: any): Promise<void> {
  try {
    if (process.env.DEBUG === 'true') {
      setLogLevel(LogLevel.DEBUG);
    }

    // Initialize the shell pool early
    await shellPool.initialize();

    // Load configuration and validate
    const { config } = await loadAndValidateConfig();
    
    debug('Discovering modules');
    
    // Discover modules
    const discoveryResult = await discoverModulesFromConfig(config);
    const modules: Module[] = discoveryResult.modules || [];
    
    debug(`Found ${modules.length} modules`);
    
    // Initialize the parent project configuration
    // Always try to find the parent first
    let parentConfig = loadParentConfig(process.cwd());
    
    // Extract tools from all sources
    const tools = extractAllTools(config, modules);
    
    // Apply filters
    const filteredTools = filterTools(tools, {
      filterSource: options.filterSource,
      filterCheck: options.filterCheck,
      filterInstall: options.filterInstall
    });
    
    // If a specific tool is requested, display just that tool
    if (toolName) {
      const toolData = filteredTools.get(toolName);
      
      if (!toolData) {
        console.error(`Tool '${toolName}' not found.`);
        process.exit(1);
      }
      
      // Get status if requested
      let statusResult;
      if (options.status) {
        statusResult = await checkToolStatus(toolName, toolData.config);
      }
      
      await displaySingleTool(toolName, toolData, { 
        detailed: options.detailed,
        status: options.status,
        statusResult
      });
      
      return;
    }
    
    // Display all tools
    const statusResults = new Map<string, ToolStatusResult>();
    
    // Check status for all tools if requested
    if (options.status) {
      const toolCount = filteredTools.size;
      
      if (toolCount > 10 && !options.yes) {
        const answer = await new Promise<string>(resolve => {
          console.log(`About to check status of ${toolCount} tools. This might take a while.`);
          console.log('Press Enter to continue or Ctrl+C to cancel...');
          
          process.stdin.once('data', (data) => {
            resolve(data.toString().trim());
          });
        });
      }
      
      let index = 0;
      for (const [toolId, toolData] of filteredTools.entries()) {
        process.stdout.write(`\rChecking tool status: ${++index}/${toolCount}`);
        try {
          statusResults.set(toolId, await checkToolStatus(toolId, toolData.config));
        } catch (error) {
          statusResults.set(toolId, { 
            status: ToolStatus.ERROR,
            error: error instanceof Error ? error : new Error(String(error))
          });
        }
      }
      process.stdout.write('\n'); // Newline after progress output
    }
    
    // Display tools based on format
    if (options.json) {
      displayToolsAsJson(filteredTools, statusResults, options);
    } else if (options.yaml) {
      displayToolsAsYaml(filteredTools, statusResults, options);
    } else {
      await displayTools(filteredTools, { 
        detailed: options.detailed,
        status: options.status,
        missing: options.missing,
        statusResults,
        filterSource: options.filterSource,
        filterCheck: options.filterCheck,
        filterInstall: options.filterInstall,
        skipStatusWarning: options.yes
      });
    }
  } catch (err) {
    console.error(`Error: ${err instanceof Error ? err.message : String(err)}`);
    process.exit(1);
  } finally {
    try {
      debug('Shutting down shell pool...');
      await shellPool.shutdown();
      debug('Shell pool shutdown complete');
    } catch (shutdownErr) {
      // Just log shutdown errors but don't fail the command
      debug(`Error during shell pool shutdown: ${shutdownErr instanceof Error ? shutdownErr.message : String(shutdownErr)}`);
    }
  }
}

/**
 * Display tools as JSON
 */
function displayToolsAsJson(
  tools: Map<string, { config: ToolConfig, source: string }>,
  statusResults: Map<string, ToolStatusResult>,
  options: { missing?: boolean }
): void {
  const result: Record<string, any> = {};
  
  for (const [toolId, toolData] of tools.entries()) {
    const statusResult = statusResults.get(toolId);
    
    // Skip if missing only and the tool is installed
    if (options.missing && statusResult?.status === ToolStatus.INSTALLED) {
      continue;
    }
    
    result[toolId] = {
      ...toolData,
      status: statusResult
    };
  }
  
  console.log(JSON.stringify(result, null, 2));
}

/**
 * Display tools as YAML
 */
function displayToolsAsYaml(
  tools: Map<string, { config: ToolConfig, source: string }>,
  statusResults: Map<string, ToolStatusResult>,
  options: { missing?: boolean }
): void {
  const result: Record<string, any> = {};
  
  for (const [toolId, toolData] of tools.entries()) {
    const statusResult = statusResults.get(toolId);
    
    // Skip if missing only and the tool is installed
    if (options.missing && statusResult?.status === ToolStatus.INSTALLED) {
      continue;
    }
    
    result[toolId] = {
      ...toolData,
      status: statusResult
    };
  }
  
  console.log(yaml.dump(result));
}

async function handleGetStatusCommand(options: any): Promise<void> {
  // This function handles the status command
  // Implementation details would depend on your requirements
  console.log('Status command handler called with options:', options);
}
