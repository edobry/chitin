/**
 * UI utilities for tools command displays
 */
import { ToolConfig } from '../../types';
import { ToolStatus, ToolStatusResult, checkToolStatus, getStatusEmoji } from '../../utils/tools';
import { displayCheckMethod, displayInstallMethod, displayAdditionalInfo, displayToolStatus, formatConfigValue } from '../../utils/ui';
import { debug, info, warn } from '../../utils/logger';
import { initBrewEnvironment, initializeBrewCaches, getBrewDisplayString } from '../../utils/homebrew';
import { DISPLAY } from '../../constants';
import { shellPool } from '../../utils/shell-pool';

/**
 * Display information about a single tool
 * @param toolId Tool identifier
 * @param toolData Tool data
 * @param options Display options
 */
export async function displaySingleTool(
  toolId: string,
  toolData: { config: ToolConfig, source: string },
  options: { detailed?: boolean, status?: boolean, statusResult?: ToolStatusResult }
): Promise<void> {
  // If we have a status result, display it with the tool name
  if (options.statusResult) {
    const statusEmoji = getStatusEmoji(options.statusResult);
    console.log(`  ${statusEmoji} üîß ${toolId}`);
  } else {
    console.log(`  üîß ${toolId}`);
  }
  
  console.log('');
  
  // Display source
  console.log(`  Source: ${toolData.source}`);
  
  // Display check method
  displayCheckMethod(toolId, toolData.config);
  
  // Display install method
  displayInstallMethod(toolData.config);
  
  // Display additional properties in detailed mode
  if (options.detailed) {
    displayAdditionalInfo(toolData.config);
  }
  
  // If status checking was requested but we don't have a result yet, check now
  if (options.status === true && !options.statusResult) {
    console.log(`  Status: Checking...`);
    try {
      const status = await checkToolStatus(toolId, toolData.config);
      const statusEmoji = getStatusEmoji(status);
      console.log(`  Status: ${formatStatus(status.status)}${status.message ? ' - ' + status.message : ''}`);
      
      // If not installed, show installation hint
      if (status.status === ToolStatus.NOT_INSTALLED) {
        showInstallationHint(toolId, toolData.config);
      }
    } catch (error) {
      console.log(`  Status: ${DISPLAY.EMOJIS.WARNING} Error checking status`);
    }
  } else if (options.statusResult) {
    // Show the status if we have a result
    const status = options.statusResult;
    
    // More concise status display - only show message for errors/unknown status
    if (status.status === ToolStatus.ERROR || status.status === ToolStatus.UNKNOWN) {
      console.log(`  Status: ${formatStatus(status.status)}${status.message ? ` - ${status.message}` : ''}`);
    } else {
      // Just show the status without detailed message for successful/not installed cases
      console.log(`  Status: ${formatStatus(status.status)}`);
    }
    
    // If not installed, show installation hint
    if (status.status === ToolStatus.NOT_INSTALLED) {
      showInstallationHint(toolId, toolData.config);
    }
  }
  
  // No trailing empty line - we'll let the display loop handle spacing between tools
}

/**
 * Format a status enum to a display string
 */
function formatStatus(status: ToolStatus): string {
  switch (status) {
    case ToolStatus.INSTALLED:
      return 'installed';
    case ToolStatus.NOT_INSTALLED:
      return 'not installed';
    case ToolStatus.ERROR:
      return 'error';
    case ToolStatus.UNKNOWN:
    default:
      return 'unknown';
  }
}

/**
 * Show installation hint for a tool that failed a check
 */
function showInstallationHint(toolId: string, config: ToolConfig): void {
  // Implementation would go here if needed
}

/**
 * Display options for tool displays
 */
export interface ToolDisplayOptions {
  detailed?: boolean;
  status?: boolean;
  missing?: boolean;
  statusResults?: Map<string, ToolStatusResult>;
  filterSource?: string;
  filterCheck?: string;
  filterInstall?: string;
  skipStatusWarning?: boolean;
}

// For tracking total check time
let totalCheckTime = 0;

/**
 * Clean up shell processes when the command completes
 */
async function cleanupShells(): Promise<void> {
  debug('Cleaning up shell processes...');
  try {
    // Use the properly imported shellPool to clean up
    await shellPool.shutdown();
    debug('Shell cleanup completed successfully');
  } catch (err) {
    debug(`Error during shell cleanup: ${err}`);
  }
}

/**
 * Display information about multiple tools
 * @param tools Tools map
 * @param options Display options
 */
export async function displayTools(
  tools: Map<string, { config: ToolConfig, source: string }>,
  options: ToolDisplayOptions
): Promise<void> {
  // Register process exit handlers for cleanup
  // This is a more robust approach than trying to cleanup at the end
  process.once('beforeExit', () => {
    debug('Process beforeExit event triggered, cleaning up...');
    cleanupShells();
  });
  
  if (tools.size === 0) {
    console.log('No tools found matching the criteria.');
    return;
  }

  // Separate full tools from references
  const fullTools = new Map();
  const toolReferences = new Map();
  
  // Categorize tools as either full configs or references
  for (const [toolId, toolData] of tools.entries()) {
    const hasFullConfig = 
      Object.keys(toolData.config).some(key => 
        ['checkCommand', 'checkBrew', 'checkPath', 'brew', 'git', 'script', 'command', 'artifact'].includes(key));
    
    if (hasFullConfig) {
      fullTools.set(toolId, toolData);
    } else {
      toolReferences.set(toolId, toolData);
    }
  }
  
  // Display legend
  displayToolsLegend({ status: options.status });
  
  console.log(`\nFound ${tools.size} tools/tool references:\n`);
  
  // Initialize status tracking
  const toolStatuses = new Map<string, ToolStatusResult>();
  
  // If status is requested and we have many tools, show warning
  if (options.status && fullTools.size > 10 && !options.skipStatusWarning) {
    console.log(`\n‚ö†Ô∏è Warning: Checking status for ${fullTools.size} tools may take a while.`);
    console.log('   Consider using filters (--filter-source, --filter-check, --filter-install) or');
    console.log('   specifying a single tool: tools get <toolname> --status\n');
  }
  
  // Group tools by source
  const toolsBySource = new Map<string, Map<string, { config: ToolConfig, source: string }>>();
  
  for (const [toolId, toolData] of fullTools.entries()) {
    const source = toolData.source;
    if (!toolsBySource.has(source)) {
      toolsBySource.set(source, new Map());
    }
    toolsBySource.get(source)!.set(toolId, toolData);
  }
  
  // Get sorted list of sources
  const sourceNames = Array.from(toolsBySource.keys()).sort();
  
  if (options.status) {
    // Pre-initialize Homebrew caches for faster checks
    debug('Pre-initializing Homebrew caches for faster tool status checks...');
    await initializeBrewCaches(10000);
    
    // Check status for all tools
    const overallStartTime = performance.now();
    let index = 0;
    const totalTools = fullTools.size;
    
    // Show progress indicator that updates in place
    process.stdout.write(`Checking tool status: 0/${totalTools}`);
    
    for (const [toolId, toolData] of fullTools.entries()) {
      const startTime = performance.now();
      
      // Update progress indicator in place
      process.stdout.write(`\rChecking tool status: ${++index}/${totalTools}`);
      
      try {
        const status = await checkToolStatus(toolId, toolData.config);
        status.checkDuration = performance.now() - startTime;
        toolStatuses.set(toolId, status);
        totalCheckTime += status.checkDuration;
      } catch (error) {
        const errorStatus = {
          status: ToolStatus.ERROR,
          error: error instanceof Error ? error : new Error(String(error)),
          checkDuration: performance.now() - startTime
        };
        toolStatuses.set(toolId, errorStatus);
        totalCheckTime += errorStatus.checkDuration;
      }
    }
    
    // Add a newline after the progress indicator
    process.stdout.write('\n\n');
  }
  
  // Display tools grouped by source
  for (const source of sourceNames) {
    const sourceTools = toolsBySource.get(source)!;
    const toolIds = Array.from(sourceTools.keys()).sort();
    
    console.log(`\n=== Source: ${source} (${toolIds.length} tools) ===\n`);
    
    for (const toolId of toolIds) {
      const toolData = sourceTools.get(toolId)!;
      
      // Add a separator before each tool with consistent spacing
      console.log(`\n‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï\n`);
      
      // Display the tool
      await displaySingleTool(toolId, toolData, {
        detailed: options.detailed,
        status: false, // We already have the status results
        statusResult: options.statusResults ? options.statusResults.get(toolId) : toolStatuses.get(toolId)
      });
    }
  }
  
  // Display tool references only if not showing missing tools
  if (toolReferences.size > 0 && !options.missing) {
    console.log(`\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);
    console.log(`=== Tool References (${toolReferences.size}) ===\n`);
    
    // Display each reference sorted by name
    const referenceNames = Array.from(toolReferences.keys()).sort();
    
    console.log('References are tools mentioned in toolDeps or similar properties but without full configuration:');
    console.log('');
    
    for (const toolId of referenceNames) {
      const toolData = toolReferences.get(toolId)!;
      console.log(`  üîó ${toolId} (referenced in ${toolData.source})`);
    }
  }

  // Display summary statistics if status was checked
  if (options.status) {
    console.log(`\n=== Summary ===\n`);
    
    // Count tools by status
    let installed = 0;
    let notInstalled = 0;
    let error = 0;
    let unknown = 0;
    
    for (const status of toolStatuses.values()) {
      switch (status.status) {
        case ToolStatus.INSTALLED:
          installed++;
          break;
        case ToolStatus.NOT_INSTALLED:
          notInstalled++;
          break;
        case ToolStatus.ERROR:
          error++;
          break;
        case ToolStatus.UNKNOWN:
          unknown++;
          break;
      }
    }
    
    console.log(`Total tools: ${fullTools.size}`);
    console.log(`  ${DISPLAY.EMOJIS.ENABLED} Installed: ${installed}`);
    console.log(`  ${DISPLAY.EMOJIS.DISABLED} Not installed: ${notInstalled}`);
    if (error > 0) {
      console.log(`  ${DISPLAY.EMOJIS.WARNING} Error: ${error}`);
    }
    if (unknown > 0) {
      console.log(`  ${DISPLAY.EMOJIS.UNKNOWN} Unknown: ${unknown}`);
    }
    
    // Count tools by source
    console.log(`\nTools by source:`);
    for (const source of sourceNames) {
      const count = toolsBySource.get(source)!.size;
      console.log(`  ${source}: ${count}`);
    }
    
    // Show total check time only once
    console.log(`\nTotal status check time: ${(totalCheckTime / 1000).toFixed(2)}s`);
  }

  // Make sure we clean up before exiting
  await cleanupShells();
}

/**
 * Display tools as JSON format
 * @param tools Tools map
 * @param statusResults Tool status results
 * @param options Display options
 */
export function displayToolsAsJson(
  tools: Map<string, { config: ToolConfig, source: string }>,
  statusResults: Map<string, ToolStatusResult>,
  options: { missing?: boolean }
): void {
  const result: Record<string, any> = {};
  
  for (const [toolId, { config, source }] of tools.entries()) {
    const statusResult = statusResults.get(toolId);
    
    // Skip non-missing tools if missing flag is set
    if (options.missing && (!statusResult || statusResult.status !== ToolStatus.NOT_INSTALLED)) {
      continue;
    }
    
    result[toolId] = {
      config,
      source,
      status: statusResult || { status: ToolStatus.UNKNOWN }
    };
  }
  
  console.log(JSON.stringify(result, null, 2));
}

/**
 * Display tools as YAML format
 * @param tools Tools map
 * @param statusResults Tool status results
 * @param options Display options
 */
export function displayToolsAsYaml(
  tools: Map<string, { config: ToolConfig, source: string }>,
  statusResults: Map<string, ToolStatusResult>,
  options: { missing?: boolean }
): void {
  // Implementation would go here
}

export function displayToolsLegend(options: { status?: boolean } = {}): void {
  console.log(`Legend: ${DISPLAY.EMOJIS.TOOL} = tool   ${DISPLAY.EMOJIS.CHECK} = check method   ${DISPLAY.EMOJIS.INSTALL}  = install method   ${DISPLAY.EMOJIS.REFERENCE} = reference`);
  if (options.status) {
    console.log(`Status: ${DISPLAY.EMOJIS.ENABLED} = installed   ${DISPLAY.EMOJIS.DISABLED} = not installed   ${DISPLAY.EMOJIS.WARNING} = error   ${DISPLAY.EMOJIS.UNKNOWN} = unknown`);
  }
  console.log('');
} 
